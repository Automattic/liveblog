{"version":3,"file":"994.bundle.js","mappings":"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","sources":["webpack://liveblog/./src/react/components/Loader.js","webpack://liveblog/./src/react/containers/PreviewContainer.js","webpack://liveblog/./src/react/components/AuthorSelectOption.js","webpack://liveblog/./src/react/components/HTMLInput.js","webpack://liveblog/./src/react/containers/EditorContainer.js","webpack://liveblog/./src/react/Editor/utils.js"],"sourcesContent":["import React from 'react';\n\nconst Loader = () => (\n  <div className=\"liveblog-loader\">\n    <div className=\"liveblog-loader-bounce1\"></div>\n    <div className=\"liveblog-loader-bounce2\"></div>\n  </div>\n);\n\nexport default Loader;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { timeout, map } from 'rxjs/operators';\n\nimport { getPreview } from '../services/api';\nimport Loader from '../components/Loader';\n\nclass PreviewContainer extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      loading: true,\n      error: false,\n      entryContent: false,\n    };\n  }\n\n  componentDidMount() {\n    const { config, getEntryContent } = this.props;\n\n    getPreview(getEntryContent(), config)\n      .pipe(\n        timeout(10000),\n        map(res => res.response),\n      )\n      .subscribe(res => this.setState({\n        entryContent: res.html,\n        loading: false,\n      }));\n  }\n\n  render() {\n    const { entryContent, loading } = this.state;\n\n    if (loading) {\n      return (\n        <div className=\"liveblog-preview\"><Loader /></div>\n      );\n    }\n\n    if (!entryContent) return false;\n\n    return (\n      <div\n        className=\"liveblog-preview\"\n        dangerouslySetInnerHTML={{ __html: entryContent }}\n      />\n    );\n  }\n}\n\nPreviewContainer.propTypes = {\n  getEntryContent: PropTypes.func,\n  config: PropTypes.object,\n};\n\nexport default PreviewContainer;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass AuthorSelectOption extends Component {\n  handleMouseDown(event) {\n    const { onSelect, option, data, selectOption } = this.props;\n    const item = data || option;\n    event.preventDefault();\n    event.stopPropagation();\n    // react-select v5 uses selectOption instead of onSelect\n    if (selectOption) {\n      selectOption(item);\n    } else if (onSelect) {\n      onSelect(item, event);\n    }\n  }\n\n  handleMouseEnter(event) {\n    const { onFocus, option, data } = this.props;\n    const item = data || option;\n    if (onFocus) onFocus(item, event);\n  }\n\n  handleMouseMove(event) {\n    const { isFocused, onFocus, option, data } = this.props;\n    if (isFocused) return;\n    const item = data || option;\n    if (onFocus) onFocus(item, event);\n  }\n\n  render() {\n    const { className, option, data } = this.props;\n    // react-select v5 uses 'data' prop instead of 'option'\n    const item = data || option || {};\n    return (\n      <div\n        className={`${className} liveblog-popover-item`}\n        onMouseDown={this.handleMouseDown.bind(this)}\n        onMouseEnter={this.handleMouseEnter.bind(this)}\n        onMouseMove={this.handleMouseMove.bind(this)}\n      >\n        { item.avatar && <div dangerouslySetInnerHTML={{ __html: item.avatar }} /> }\n        {item.name}\n      </div>\n    );\n  }\n}\n\nAuthorSelectOption.propTypes = {\n  onSelect: PropTypes.func,\n  option: PropTypes.object,\n  onFocus: PropTypes.func,\n  isFocused: PropTypes.bool,\n  className: PropTypes.string,\n};\n\nexport default AuthorSelectOption;\n","import React, { useEffect } from 'react';\n\nimport AceEditor from 'react-ace';\nimport { config } from 'ace-builds';\nimport PropTypes from 'prop-types';\nimport 'ace-builds/src-noconflict/mode-html';\nimport 'ace-builds/src-noconflict/theme-tomorrow';\n\n// Configure Ace to not use workers (prevents 404 errors for worker files)\nconfig.set('useWorker', false);\n\nconst HTMLInput = ({ container = true, ...props }) => (\n  <div className={`liveblog-html-editor ${container ? 'liveblog-html-editor-container' : ''}`}>\n    <AceEditor\n      mode=\"html\"\n      theme=\"tomorrow\"\n      name=\"raw-editor\"\n      fontSize={13}\n      showGutter={false}\n      highlightActiveLine={true}\n      tabSize={2}\n      blockScrolling=\"Infinity\"\n      {...props}\n    />\n  </div>\n);\n\nHTMLInput.propTypes = {\n  container: PropTypes.bool,\n};\n\n\nexport default HTMLInput;\n","/* eslint-disable no-return-assign */\n/* eslint-disable react/prop-types */\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { bindActionCreators } from 'redux';\nimport { connect } from 'react-redux';\nimport { AsyncPaginate as Async } from 'react-select-async-paginate';\nimport { html } from 'js-beautify';\nimport { timeout, map } from 'rxjs/operators';\n\nimport * as apiActions from '../actions/apiActions';\nimport * as userActions from '../actions/userActions';\n\nimport { getAuthors, getHashtags, uploadImage } from '../services/api';\n\nimport PreviewContainer from './PreviewContainer';\nimport AuthorSelectOption from '../components/AuthorSelectOption';\nimport HTMLInput from '../components/HTMLInput';\n\nimport { getImageSize } from '../Editor/utils';\n\n// Lazy load LexicalEditor for code splitting\nconst LexicalEditor = React.lazy( () => import( '../Editor/LexicalEditor' ) );\n\nclass EditorContainer extends Component {\n  constructor(props) {\n    super(props);\n\n    const initialAuthors = props.entry\n      ? props.entry.authors\n      : [props.config.current_user];\n\n    this.state = {\n      suggestions: [],\n      authors: initialAuthors,\n      mode: 'editor',\n      readOnly: false,\n      rawText: props.entry ? props.entry.content : '',\n      previewKey: 0,\n      // Store the HTML content for the editor\n      editorContent: props.entry ? props.entry.content : '',\n    };\n  }\n\n  setReadOnly(state) {\n    this.setState({\n      readOnly: state,\n    });\n  }\n\n  getContent() {\n    return this.state.editorContent;\n  }\n\n  /**\n   * Handle content changes from the Lexical editor.\n   *\n   * @param {string} htmlContent - The updated HTML content.\n   */\n  onEditorChange(htmlContent) {\n    this.setState({\n      editorContent: htmlContent,\n      rawText: html(htmlContent),\n    });\n  }\n\n  /**\n   * Sync raw HTML text input back to editor content.\n   */\n  syncRawTextToEditorContent() {\n    this.setState(prevState => ({\n      editorContent: prevState.rawText,\n      // Increment previewKey to force LexicalEditor to remount with new content\n      previewKey: prevState.previewKey + 1,\n    }));\n  }\n\n  publish() {\n    const { updateEntry, entry, entryEditClose, createEntry, isEditing } = this.props;\n    const { authors, editorContent } = this.state;\n    const content = this.getContent();\n    const authorIds = authors.map(author => author.id);\n    const author = authorIds.length > 0 ? authorIds[0] : false;\n    const contributors = authorIds.length > 1 ? authorIds.slice(1, authorIds.length) : false;\n    const htmlregex = /<(img|picture|video|audio|canvas|svg|iframe|embed) ?.*>/;\n\n    // We don't want an editor publishing empty entries\n    // So we must check if there is any text within the editor\n    // If we fail to find text then we should check for a valid\n    // list of html elements, mainly visual for example images.\n    const textContent = editorContent.replace(/<[^>]*>/g, '').trim();\n    if (!textContent && htmlregex.exec(editorContent) === null) {\n      return;\n    }\n\n    if (isEditing) {\n      updateEntry({\n        id: entry.id,\n        content,\n        author,\n        contributors,\n      });\n      entryEditClose(entry.id);\n      return;\n    }\n\n    createEntry({\n      content,\n      author,\n      contributors,\n    });\n\n    // Clear editor content by incrementing previewKey to force remount\n    this.setState(prevState => ({\n      editorContent: '',\n      rawText: '',\n      readOnly: false,\n      previewKey: prevState.previewKey + 1,\n    }));\n  }\n\n  onSelectAuthorChange(value) {\n    this.setState({\n      authors: value,\n    });\n  }\n\n  getUsers(text) {\n    const { config } = this.props;\n\n    // Handle empty text - return empty options immediately\n    if (!text || text.trim() === '') {\n      return Promise.resolve({ options: [] });\n    }\n\n    return new Promise((resolve) => {\n      getAuthors(text, config)\n        .pipe(\n          timeout(10000),\n          map(res => res.response),\n        )\n        .subscribe({\n          next: res => resolve({ options: res || [] }),\n          error: err => {\n            // Fail gracefully with empty options on error (e.g., 401)\n            console.warn('Authors API error:', err);\n            resolve({ options: [] });\n          },\n        });\n    });\n  }\n\n  getAuthorsForAutocomplete(text) {\n    const { config } = this.props;\n    getAuthors(text, config)\n      .pipe(\n        timeout(10000),\n        map(res => res.response),\n      )\n      .subscribe(res => this.setState({\n        suggestions: res.map(author => author),\n      }));\n  }\n\n  getHashtags(text) {\n    const { config } = this.props;\n    getHashtags(text, config)\n      .pipe(\n        timeout(10000),\n        map(res => res.response),\n      )\n      .subscribe(res => this.setState({\n        suggestions: res.map(hashtag => hashtag),\n      }));\n  }\n\n  filterCommandSuggestions(suggestions, filter) {\n    this.setState({\n      suggestions: suggestions.filter(item =>\n        item.substring(0, filter.length) === filter,\n      ),\n    });\n  }\n\n  filterEmojiSuggestions(suggestions, filter) {\n    this.setState({\n      suggestions: suggestions.filter(item =>\n        item.key.toString().substring(0, filter.length) === filter,\n      ),\n    });\n  }\n\n  handleOnSearch(trigger, text) {\n    const { config } = this.props;\n\n    switch (trigger) {\n      case '@':\n        this.getAuthorsForAutocomplete(text);\n        break;\n      case '#':\n        this.getHashtags(text);\n        break;\n      case '/':\n        this.filterCommandSuggestions(config.autocomplete[0].data, text);\n        break;\n      case ':':\n        this.filterEmojiSuggestions(config.autocomplete[1].data, text);\n        break;\n      default:\n        this.setState({ suggestions: [] });\n        break;\n    }\n  }\n\n  handleImageUpload(file) {\n    const { config } = this.props;\n\n    const formData = new FormData();\n    formData.append('name', file.name);\n    formData.append('action', 'upload-attachment');\n    formData.append('_wpnonce', config.image_nonce);\n    formData.append('async-upload', file);\n\n    return new Promise((resolve, reject) => {\n      uploadImage(formData)\n        .pipe(\n          timeout(60000),\n          map(res => res.response),\n        )\n        .subscribe({\n          next: (res) => {\n            const src = getImageSize(res.data.sizes, config.default_image_size);\n            resolve(src);\n          },\n          error: err => reject(err),\n        });\n    });\n  }\n\n  render() {\n    const {\n      suggestions,\n      mode,\n      authors,\n      readOnly,\n      previewKey,\n    } = this.state;\n\n    const { isEditing, config } = this.props;\n\n    return (\n      <div className=\"liveblog-editor-container\">\n        {!isEditing && <h1 className=\"liveblog-editor-title\">Add New Entry</h1>}\n        <div className=\"liveblog-editor-tabs\">\n          <button\n            className={`liveblog-editor-tab ${mode === 'editor' ? 'is-active' : ''}`}\n            onClick={() => this.setState({ mode: 'editor' })}\n          >\n            Visual\n          </button>\n          <button\n            className={`liveblog-editor-tab ${mode === 'raw' ? 'is-active' : ''}`}\n            onClick={() => this.setState({ mode: 'raw' })}\n          >\n              Text\n          </button>\n          <button\n            className={`liveblog-editor-tab ${mode === 'preview' ? 'is-active' : ''}`}\n            onClick={() => this.setState({ mode: 'preview' })}\n          >\n              Preview\n          </button>\n        </div>\n        {\n          mode === 'preview' &&\n          <PreviewContainer\n            key={previewKey}\n            config={config}\n            getEntryContent={() => this.getContent()}\n          />\n        }\n        {\n          mode === 'editor' &&\n          <React.Suspense fallback={<div className=\"liveblog-editor-loading\">Loading editor...</div>}>\n            <LexicalEditor\n              key={previewKey}\n              initialContent={this.state.editorContent}\n              onChange={this.onEditorChange.bind(this)}\n              readOnly={readOnly}\n              suggestions={suggestions}\n              onSearch={(trigger, text) => this.handleOnSearch(trigger, text)}\n              handleImageUpload={this.handleImageUpload.bind(this)}\n            />\n          </React.Suspense>\n        }\n        {\n          mode === 'raw' &&\n          <HTMLInput\n            value={this.state.rawText}\n            onChange={(text) => {\n              this.setState({ rawText: text }, () => {\n                this.syncRawTextToEditorContent();\n              });\n            }}\n            height=\"275px\"\n            width=\"100%\"\n          />\n        }\n        <h2 className=\"liveblog-editor-subTitle\">Authors:</h2>\n        <Async\n          isMulti={true}\n          value={authors}\n          getOptionValue={(option) => option.key}\n          getOptionLabel={(option) => option.name}\n          onChange={this.onSelectAuthorChange.bind(this)}\n          components={{ Option: AuthorSelectOption }}\n          loadOptions={this.getUsers.bind(this)}\n          isClearable={false}\n          cacheOptions={false}\n        />\n        <button className=\"liveblog-btn liveblog-publish-btn\" onClick={this.publish.bind(this)}>\n          {isEditing ? 'Publish Update' : 'Publish New Entry'}\n        </button>\n      </div>\n    );\n  }\n}\n\nEditorContainer.propTypes = {\n  config: PropTypes.object,\n  updateEntry: PropTypes.func,\n  entry: PropTypes.object,\n  entryEditClose: PropTypes.func,\n  createEntry: PropTypes.func,\n  isEditing: PropTypes.bool,\n  authors: PropTypes.array,\n  getAuthors: PropTypes.func,\n};\n\nconst mapStateToProps = state => state;\n\nconst mapDispatchToProps = dispatch =>\n  bindActionCreators({\n    ...apiActions,\n    ...userActions },\n  dispatch);\n\nexport default connect(mapStateToProps, mapDispatchToProps)(EditorContainer);\n","/* eslint-disable no-param-reassign */\n\n/**\n * Returns the highest last index of an array of characters.\n */\nexport const getLastIndexOf = (string, characters = []) =>\n  characters.reduce((accumulator, character) =>\n    Math.max(string.lastIndexOf(character), accumulator), -1);\n\n/**\n * Simple templating function that replaces ${data} with a key value.\n */\nconst get = (path, obj, fb = `$\\{${path}}`) =>\n  path.split('.').reduce((res, key) => res[key] || fb, obj);\n\nexport const parseTemplate = (template, map, fallback) =>\n  template.replace(/\\$\\{.+?}/g, (match) => {\n    const path = match.substr(2, match.length - 3).trim();\n    return get(path, map, fallback);\n  });\n\n/**\n * Returns boolean if selection contains entity\n */\nexport const hasEntityAtSelection = (editorState, selectionState = false) => {\n  const selection = selectionState || editorState.getSelection();\n  if (!selection.getHasFocus()) return false;\n  const contentState = editorState.getCurrentContent();\n  const block = contentState.getBlockForKey(selection.getStartKey());\n  const entityKey = block.getEntityAt(selection.getStartOffset() - 1);\n  if (!entityKey) return false;\n  return contentState.getEntity(entityKey);\n};\n\n/**\n * Gets the range of an autocomplete trigger from the trigger character to where\n * the user is typing.\n */\nexport const getTriggerRange = (triggers) => {\n  const selection = window.getSelection();\n  if (selection.rangeCount === 0) return null;\n  const range = selection.getRangeAt(0);\n  const text = range.startContainer.textContent.substring(0, range.startOffset);\n\n  // If the last character is a space bail.\n  if (/\\s+$/.test(text)) return null;\n\n  const index = getLastIndexOf(text, triggers);\n  if (index === -1) return null;\n\n  return {\n    text: text.substring(index),\n    start: index,\n    end: range.startOffset,\n  };\n};\n\n/**\n * Gets the autocomplete insert range to replace the trigger range with an enitity.\n */\nexport const getInsertRange = (autocompleteState, editorState) => {\n  const currentSelectionState = editorState.getSelection();\n  const end = currentSelectionState.getAnchorOffset();\n  const anchorKey = currentSelectionState.getAnchorKey();\n  const currentContent = editorState.getCurrentContent();\n  const currentBlock = currentContent.getBlockForKey(anchorKey);\n  const blockText = currentBlock.getText();\n  const start = blockText.substring(0, end).lastIndexOf(autocompleteState.trigger);\n\n  return {\n    start,\n    end,\n  };\n};\n\n/**\n * Returns a number of the top position of trigger range to poistion the suggestion popover.\n */\nexport const getTopPosition = (range, parent) => {\n  const tempRange = window.getSelection().getRangeAt(0).cloneRange();\n  tempRange.setStart(tempRange.startContainer, range.start);\n  const parentRect = parent.getBoundingClientRect();\n  const rect = tempRange.getBoundingClientRect();\n  return (rect.top - parentRect.top) + rect.height;\n};\n\n/**\n * If an element is hidden in a scrollable box then make it visible.\n */\nexport const scrollElementIfNotInView = (childElement, parentElement) => {\n  const parentClientRect = parentElement.getBoundingClientRect();\n  const parentBottom = parentClientRect.bottom;\n  const parentTop = parentClientRect.top;\n\n  const childRect = childElement.getBoundingClientRect();\n  const childBottom = childRect.bottom;\n  const childTop = childRect.top;\n  if (childBottom > parentBottom) parentElement.scrollTop += childRect.height;\n  if (childTop < parentTop) parentElement.scrollTop -= childRect.height;\n};\n\n/**\n * Returns an array of all the blocks at a selection given a start and end key.\n */\nexport const getSelectedBlocks = (contentState, anchorKey, focusKey) => {\n  const isSameBlock = anchorKey === focusKey;\n  const startingBlock = contentState.getBlockForKey(anchorKey);\n  const selectedBlocks = [startingBlock];\n\n  if (!isSameBlock) {\n    let blockKey = anchorKey;\n\n    while (blockKey !== focusKey) {\n      const nextBlock = contentState.getBlockAfter(blockKey);\n      selectedBlocks.push(nextBlock);\n      blockKey = nextBlock.getKey();\n    }\n  }\n\n  return selectedBlocks;\n};\n\n/**\n * Check if a focusable block is focused/selected\n */\nexport const focusableBlockIsSelected = (editorState) => {\n  const selection = editorState.getSelection();\n  if (selection.getAnchorKey() !== selection.getFocusKey()) {\n    return false;\n  }\n  const content = editorState.getCurrentContent();\n  const block = content.getBlockForKey(selection.getAnchorKey());\n  if (block.getType() === 'atomic') return block;\n  return false;\n};\n\n/**\n * Get the most suitable image size.\n * @param {object} image\n * @param {string} selectedSize\n */\nexport const getImageSize = (sizes, defaultSize) => {\n  if (!sizes) return '';\n  if (sizes[defaultSize]) {\n    return sizes[defaultSize].source_url || sizes[defaultSize].url;\n  }\n  if (sizes.full) {\n    return sizes.full.source_url || sizes.full.url;\n  }\n  return '';\n};\n\n/**\n * Map a NamedNodeMap to an object and map the class attribute to className\n * for React.\n * @param {namedNodeMap} attributes\n */\nexport const namedNodeMapToObject = namedNodeMap =>\n  Array.from(namedNodeMap).reduce((object, item) => ({\n    ...object,\n    [item.name === 'class' ? 'className' : item.name]: item.value,\n  }), {});\n"],"names":["Loader","_jsxs","className","children","_jsx","PreviewContainer","Component","constructor","props","super","this","state","loading","error","entryContent","componentDidMount","config","getEntryContent","getPreview","pipe","timeout","map","res","response","subscribe","setState","html","render","dangerouslySetInnerHTML","__html","propTypes","PropTypes","AuthorSelectOption","handleMouseDown","event","onSelect","option","data","selectOption","item","preventDefault","stopPropagation","handleMouseEnter","onFocus","handleMouseMove","isFocused","onMouseDown","bind","onMouseEnter","onMouseMove","avatar","name","set","HTMLInput","container","AceEditor","mode","theme","fontSize","showGutter","highlightActiveLine","tabSize","blockScrolling","LexicalEditor","React","EditorContainer","initialAuthors","entry","authors","current_user","suggestions","readOnly","rawText","content","previewKey","editorContent","setReadOnly","getContent","onEditorChange","htmlContent","syncRawTextToEditorContent","prevState","publish","updateEntry","entryEditClose","createEntry","isEditing","authorIds","author","id","length","contributors","slice","replace","trim","exec","onSelectAuthorChange","value","getUsers","text","Promise","resolve","getAuthors","next","options","err","console","warn","getAuthorsForAutocomplete","getHashtags","hashtag","filterCommandSuggestions","filter","substring","filterEmojiSuggestions","key","toString","handleOnSearch","trigger","autocomplete","handleImageUpload","file","formData","FormData","append","image_nonce","reject","uploadImage","src","sizes","defaultSize","default_image_size","source_url","url","full","getImageSize","onClick","fallback","initialContent","onChange","onSearch","height","width","Async","isMulti","getOptionValue","getOptionLabel","components","Option","loadOptions","isClearable","cacheOptions","connect","dispatch","bindActionCreators","apiActions","userActions"],"ignoreList":[],"sourceRoot":""}